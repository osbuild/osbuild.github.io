"use strict";(self.webpackChunksaurus=self.webpackChunksaurus||[]).push([[5113],{6204:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var s=t(5893),o=t(1151);const i={},r="org.osbuild.oscap.remediation",a={id:"developer-guide/projects/osbuild/modules/stages/org.osbuild.oscap.remediation",title:"org.osbuild.oscap.remediation",description:"Execute oscap remediation",source:"@site/docs/developer-guide/02-projects/osbuild/modules/stages/org.osbuild.oscap.remediation.md",sourceDirName:"developer-guide/02-projects/osbuild/modules/stages",slug:"/developer-guide/projects/osbuild/modules/stages/org.osbuild.oscap.remediation",permalink:"/docs/developer-guide/projects/osbuild/modules/stages/org.osbuild.oscap.remediation",draft:!1,unlisted:!1,editUrl:"https://github.com/osbuild/osbuild.github.io/tree/main/docs/developer-guide/02-projects/osbuild/modules/stages/org.osbuild.oscap.remediation.md",tags:[],version:"current",frontMatter:{},sidebar:"developer",previous:{title:"org.osbuild.oscap.autotailor",permalink:"/docs/developer-guide/projects/osbuild/modules/stages/org.osbuild.oscap.autotailor"},next:{title:"org.osbuild.ostree.aleph",permalink:"/docs/developer-guide/projects/osbuild/modules/stages/org.osbuild.ostree.aleph"}},d={},l=[{value:"Schema 1",id:"schema-1",level:2},{value:"Schema 2",id:"schema-2",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"orgosbuildoscapremediation",children:"org.osbuild.oscap.remediation"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Execute oscap remediation"})}),"\n",(0,s.jsxs)(n.p,{children:["The OpenSCAP scanner can be run on the image tree and the remediation can be carried\nout during build time. The stage takes the OpenSCAP config as input and then runs the\nthe utility in chroot to scan and remediate [1] the tree during image at build time.\nThe stage generates an html report and xml results file both saved to the ",(0,s.jsx)(n.code,{children:"data_dir"}),"\ndirectory. It defaults to ",(0,s.jsx)(n.code,{children:"/root"})," if not configured.\n[1] ",(0,s.jsx)(n.a,{href:"https://github.com/OpenSCAP/openscap/blob/maint-1.3/docs/manual/manual.adoc#remediating-system",children:"https://github.com/OpenSCAP/openscap/blob/maint-1.3/docs/manual/manual.adoc#remediating-system"}),"\nBuildhost commands used: ",(0,s.jsx)(n.code,{children:"chroot"}),", ",(0,s.jsx)(n.code,{children:"xz"}),"."]}),"\n",(0,s.jsx)(n.h2,{id:"schema-1",children:"Schema 1"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "additionalProperties": false,\n  "required": [\n    "config"\n  ],\n  "properties": {\n    "data_dir": {\n      "type": "string",\n      "default": "/root",\n      "description": "Path to directory where OpenSCAP reports and results should be saved"\n    },\n    "config": {\n      "additionalProperties": false,\n      "required": [\n        "profile_id",\n        "datastream"\n      ],\n      "type": "object",\n      "description": "OpenSCAP configuration variables",\n      "properties": {\n        "profile_id": {\n          "type": "string",\n          "description": "The SCAP (XCCDF) profile id"\n        },\n        "datastream": {\n          "type": "string",\n          "description": "The path to the data stream file"\n        },\n        "datastream_id": {\n          "type": "string",\n          "description": "The data stream id"\n        },\n        "xccdf_id": {\n          "type": "string",\n          "description": "The XCCDF id"\n        },\n        "benchmark_id": {\n          "type": "string",\n          "description": "The benchmark id"\n        },\n        "tailoring": {\n          "type": "string",\n          "description": "The path to the custom tailoring file"\n        },\n        "tailoring_id": {\n          "type": "string",\n          "description": "The tailoring id"\n        },\n        "arf_results": {\n          "type": "string",\n          "description": "Filename for storing the ARF results file"\n        },\n        "xml_results": {\n          "type": "string",\n          "description": "Filename for storing the ARF results file (synonym for arf_results)"\n        },\n        "xccdf_results": {\n          "type": "string",\n          "default": "oscap_eval_xccdf_results.xml",\n          "description": "Filename for storing the XCCDF results file"\n        },\n        "html_report": {\n          "type": "string",\n          "description": "Filename for saving the final HTML report"\n        },\n        "verbose_log": {\n          "type": "string",\n          "description": "Filename for verbose error messages"\n        },\n        "verbose_level": {\n          "type": "string",\n          "enum": [\n            "DEVEL",\n            "INFO",\n            "WARNING",\n            "ERROR"\n          ],\n          "description": "The verbosity level for the log messages"\n        },\n        "compress_results": {\n          "type": "boolean",\n          "default": false,\n          "description": "Compress ARF and XCCDF results file(s) with xz"\n        }\n      }\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"schema-2",children:"Schema 2"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:"{}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>a,a:()=>r});var s=t(7294);const o={},i=s.createContext(o);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);