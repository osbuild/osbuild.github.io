"use strict";(self.webpackChunksaurus=self.webpackChunksaurus||[]).push([[8163],{1050:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>u,frontMatter:()=>r,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"developer-guide/projects/osbuild/modules/stages/org.osbuild.copy","title":"org.osbuild.copy","description":"\x3c!--","source":"@site/docs/developer-guide/02-projects/osbuild/modules/stages/org.osbuild.copy.md","sourceDirName":"developer-guide/02-projects/osbuild/modules/stages","slug":"/developer-guide/projects/osbuild/modules/stages/org.osbuild.copy","permalink":"/docs/developer-guide/projects/osbuild/modules/stages/org.osbuild.copy","draft":false,"unlisted":false,"editUrl":"https://github.com/osbuild/osbuild/tree/main/stages/org.osbuild.copy.meta.json","tags":[],"version":"current","frontMatter":{"custom_edit_url":"https://github.com/osbuild/osbuild/tree/main/stages/org.osbuild.copy.meta.json"},"sidebar":"developer","previous":{"title":"org.osbuild.containers.unit.create","permalink":"/docs/developer-guide/projects/osbuild/modules/stages/org.osbuild.containers.unit.create"},"next":{"title":"org.osbuild.coreos.live-artifacts.mono","permalink":"/docs/developer-guide/projects/osbuild/modules/stages/org.osbuild.coreos.live-artifacts.mono"}}');var s=t(4848),i=t(8453);const r={custom_edit_url:"https://github.com/osbuild/osbuild/tree/main/stages/org.osbuild.copy.meta.json"},d="org.osbuild.copy",c={},a=[{value:"Schema 1",id:"schema-1",level:2},{value:"Schema 2",id:"schema-2",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"orgosbuildcopy",children:"org.osbuild.copy"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Copy items"})}),"\n",(0,s.jsxs)(n.p,{children:["Stage to copy items, that is files or trees, from inputs to mount\npoints or the tree. Multiple items can be copied. The source and\ndestination is an URL. Supported locations ('schemes') are ",(0,s.jsx)(n.code,{children:"tree"}),",\n",(0,s.jsx)(n.code,{children:"mount"})," and ",(0,s.jsx)(n.code,{children:"input"}),".\nThe path format follows the rsync convention that if the paths\nends with a slash ",(0,s.jsx)(n.code,{children:"/"})," the content of that directory is copied not\nthe directory itself.\nNote that the stage by default does not remove the destination\nbefore copying. As a result, if the destination is an existing\nsymlink to a file, then this file will be overwritten, instead of\nthe symlink being replaced. If you want to replace the symlink\nwith a file, you need to set the ",(0,s.jsx)(n.code,{children:"remove_destination"})," option to\n",(0,s.jsx)(n.code,{children:"true"}),". This option works only for files, not directories or\nsymlinks to directories."]}),"\n",(0,s.jsx)(n.h2,{id:"schema-1",children:"Schema 1"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:"{}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"schema-2",children:"Schema 2"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "options": {\n    "additionalProperties": false,\n    "required": [\n      "paths"\n    ],\n    "properties": {\n      "paths": {\n        "description": "Array of items to copy",\n        "type": "array",\n        "minItems": 1,\n        "items": {\n          "type": "object",\n          "additionalProperties": false,\n          "required": [\n            "from",\n            "to"\n          ],\n          "properties": {\n            "from": {\n              "oneOf": [\n                {\n                  "type": "string",\n                  "description": "The source, if an input",\n                  "pattern": "^input://[^/]+/"\n                },\n                {\n                  "type": "string",\n                  "description": "The source, if a mount",\n                  "pattern": "^mount://[^/]+/"\n                },\n                {\n                  "type": "string",\n                  "description": "The source, if the tree",\n                  "pattern": "^tree:///"\n                }\n              ]\n            },\n            "to": {\n              "oneOf": [\n                {\n                  "type": "string",\n                  "description": "The destination, if a mount",\n                  "pattern": "^mount://[^/]+/"\n                },\n                {\n                  "type": "string",\n                  "description": "The destination, if the tree",\n                  "pattern": "^tree:///"\n                }\n              ]\n            },\n            "remove_destination": {\n              "type": "boolean",\n              "description": "Remove the destination before copying. Works only for files, not directories.",\n              "default": false\n            }\n          }\n        }\n      }\n    }\n  },\n  "devices": {\n    "type": "object",\n    "additionalProperties": true\n  },\n  "mounts": {\n    "type": "array"\n  },\n  "inputs": {\n    "type": "object",\n    "additionalProperties": true\n  }\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>d});var o=t(6540);const s={},i=o.createContext(s);function r(e){const n=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:n},e.children)}}}]);